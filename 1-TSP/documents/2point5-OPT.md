# Between 2-Opt and 3-Opt

Extract from _Local Search in Combinatorial Optimization_ by Emile H. L. Aarts,J. K. Lenstra

A simple extension is what Bentley [1992] calls 2.5-Opt. In this algorithm we expand the 2-Opt neighborhood to include a simple form of 3-Opt move that can be found with little extra effort. In a 2.5-Opt move one relocates a single city from its current location to a position between two current tour neighbors elsewhere in the tour. In Figure 8.2, this corresponds to the situation where b and c are the same city. The search for such moves can be incorporated into our basic 2-Opt search as follows: for each t3 candidate (i.e., each city that is closer to t2 than is t1) we evaluate the corresponding 2-Opt move plus the 2.5-Opt move that places t2 between 13 and 14 and the 2.5-Opt move that places t3 between tl and /2. Bentley [1992] has implemented 2.5-Opt for geometric instances using the on-the-fly approach. For random Euclidean instances it yields a 0.5% improvement in average tour length over 2-Opt at the cost of a 30-40% increase in running time. For our test bed of TSPLIB instances, the improvement in tour length over 2-Opt was more like 1 %. This was still 1% worse than obtained by our neighbor-list implementation of full 3-Opt, but it took only half the time. A second algorithm that is intermediate between 2-Opt and 3-Opt is the Or-Opt algorithm originally proposed by Or [1976] and popularized by Golden & Stewart [1985]. Here we restrict attention to 3-Opt moves in which a segment consisting of three or fewer consecutive cities is excised from the tour and placed between two tour neighbors elsewhere in the tour. In Figure 8.2 this corresponds to the situation where cities b and c are 0, 1, or 2 cities apart in the tour, a natural generalization of the 2.5-Opt move. A version of Or-Opt could be implemented by slightly modifying an implementation of 2.5-Opt. Such an implementation should be a little faster than full 3-Opt, although a slight loss in tour quality is to be expected. To data, however, Or-opt has only been studied by researchers who assumed that 3-Opt requires 0(N3) time and so settled for Or-Opt implementa-tions that take quadratic time. Such implementations are not competitive with neighbor-list implementation of full 3-Opt in either running time or tour quality.
